{
  "language": "Solidity",
  "sources": {
    "contracts/GeneralFund.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract GeneralFund {\r\n\tstruct AddedUsers {\r\n\t\tuint256 userId; //user counter, starting with 1\r\n\t\tstring userMsg; //TODO: not needed?\r\n\t\tuint16 voteCounter;\r\n\t}\r\n\r\n\tstruct Members {\r\n\t\tuint256 memberId; //member counter, starting with 1\r\n\t\tstring message; //TODO: not needed?\r\n\t\tuint256 timestampAdded;\r\n\t}\r\n\r\n\t//PRODTODO: uint256 public constant frequency = 2592000; //2,592,000 seconds is 4 weeks\r\n\tuint256 public constant frequency = 1000;\r\n\tuint256 public lastTimestamp;\r\n\tuint256 public totalAddedSelf = 0;\r\n\tuint256 public totalMembers = 0;\r\n\tuint256 public totalMonthlyFundsAvailable = 0;\r\n\tuint256 public usersMonthlyLimit = 0;\r\n\tuint16 public constant threshold = 2; //TODO: change to 5\r\n\tmapping(address => AddedUsers) public userObjs;\r\n\tmapping(address => Members) public memberObjs;\r\n\tmapping(address => address[]) public vouches; //user => addresses of those who vouched for this user\r\n\tmapping(address => uint256) public memberLastWithdrawal; //user => block.timestamp of their last withdrawal\r\n\r\n\t//todo: change to your addresses\r\n\taddress[] public originalMembers = [\r\n\t\t0x1e7aAbB9D0C701208E875131d0A1cFcDAba79350,\r\n\t\t0x75990d2df3b7699fB84D1d54978eC8b279dD4c11\r\n\t];\r\n\r\n\tevent UserAddedSelf(\r\n\t\taddress userAddress,\r\n\t\tstring userMsg,\r\n\t\tuint256 userNumber\r\n\t);\r\n\r\n\tevent UserVouchedFor(\r\n\t\tbytes userId,\r\n\t\taddress userAddress,\r\n\t\taddress voucherAddress,\r\n\t\tstring reasonVouchingFor //TODO: not needed?\r\n\t);\r\n\r\n\tevent Member(\r\n\t\t// address indexed userAddress,\r\n\t\taddress memberAddress,\r\n\t\tstring memberMsg,\r\n\t\tuint256 memberNumber\r\n\t);\r\n\r\n\tevent Month(\r\n\t\tuint256 startTimestamp,\r\n\t\tuint256 endTimestamp,\r\n\t\tuint256 funds,\r\n\t\tuint256 members,\r\n\t\tuint256 fundsPerMember\r\n\t);\r\n\r\n\tevent MemberWithdrawal(address memberAddress, uint256 amount);\r\n\r\n\tevent Donation(address donor, uint256 amount);\r\n\r\n\tmodifier notVouchingForSelf(address userToVouchFor, address vouching) {\r\n\t\trequire(userToVouchFor != vouching, \"You can not vouch for yourself.\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notAlreadyVouched(address userToVouchFor, address vouching) {\r\n\t\trequire(\r\n\t\t\t!addressHasVouchedForUser(userToVouchFor, vouching),\r\n\t\t\t\"This address has already vouched for this user.\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier lessThanThreshold(address userToVouchFor) {\r\n\t\trequire(\r\n\t\t\tvouches[userToVouchFor].length < threshold,\r\n\t\t\t\"This user already has enough vouches.\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notAUser(address potentialUser) {\r\n\t\trequire(\r\n\t\t\tuserObjs[potentialUser].userId == 0,\r\n\t\t\t\"Address is already a User.\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier notAMember(address potentialMember) {\r\n\t\trequire(\r\n\t\t\tmemberObjs[potentialMember].memberId == 0,\r\n\t\t\t\"Address is already a Member.\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier isAMember(address potentialMember) {\r\n\t\trequire(\r\n\t\t\tmemberObjs[potentialMember].memberId != 0,\r\n\t\t\t\"Address is NOT a Member.\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier memberCanWithdraw(address member) {\r\n\t\trequire(\r\n\t\t\tmemberLastWithdrawal[member] < lastTimestamp,\r\n\t\t\t\"You have already withdrawn once this month.\"\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor() {\r\n\t\tfor (uint16 i = 0; i < originalMembers.length; i++) {\r\n\t\t\tmakeNewMember(originalMembers[i]);\r\n\t\t}\r\n\t\tlastTimestamp = block.timestamp;\r\n\t}\r\n\r\n\tfunction addSelf(\r\n\t\tstring memory _whyAddedSelf\r\n\t) external notAUser(msg.sender) notAMember(msg.sender) {\r\n\t\ttotalAddedSelf++;\r\n\t\tAddedUsers storage thisUserObj = userObjs[msg.sender];\r\n\t\tthisUserObj.userId = totalAddedSelf;\r\n\t\tthisUserObj.voteCounter = 0;\r\n\t\tthisUserObj.userMsg = _whyAddedSelf;\r\n\r\n\t\temit UserAddedSelf(msg.sender, _whyAddedSelf, totalAddedSelf);\r\n\t}\r\n\r\n\tfunction vouchForUser(\r\n\t\tbytes calldata _userId,\r\n\t\taddress _userVouchingFor,\r\n\t\tstring memory _reasonForVouching\r\n\t)\r\n\t\texternal\r\n\t\tisAMember(msg.sender)\r\n\t\tnotVouchingForSelf(_userVouchingFor, msg.sender)\r\n\t\tnotAlreadyVouched(_userVouchingFor, msg.sender)\r\n\t\tlessThanThreshold(_userVouchingFor)\r\n\t{\r\n\t\tuserObjs[_userVouchingFor].voteCounter++;\r\n\t\tvouches[_userVouchingFor].push(msg.sender);\r\n\r\n\t\temit UserVouchedFor(\r\n\t\t\t_userId,\r\n\t\t\t_userVouchingFor,\r\n\t\t\tmsg.sender,\r\n\t\t\t_reasonForVouching\r\n\t\t);\r\n\r\n\t\t//if enough votes - make a member\r\n\t\tif (userObjs[_userVouchingFor].voteCounter >= threshold) {\r\n\t\t\tmakeNewMember(_userVouchingFor);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction makeNewMember(address _memberAddress) private {\r\n\t\ttotalMembers++;\r\n\t\tMembers storage thisMemberObj = memberObjs[_memberAddress];\r\n\t\tthisMemberObj.memberId = totalMembers;\r\n\t\tthisMemberObj.message = userObjs[_memberAddress].userMsg;\r\n\t\tthisMemberObj.timestampAdded = block.timestamp;\r\n\r\n\t\temit Member(\r\n\t\t\t_memberAddress,\r\n\t\t\tuserObjs[_memberAddress].userMsg,\r\n\t\t\ttotalMembers\r\n\t\t);\r\n\t}\r\n\r\n\tfunction memberWithdrawal()\r\n\t\texternal\r\n\t\tisAMember(msg.sender)\r\n\t\tmemberCanWithdraw(msg.sender)\r\n\t{\r\n\t\trequire(address(this).balance > 0, \"Sorry! The fund is empty.\");\r\n\t\trequire(\r\n\t\t\taddress(this).balance >= usersMonthlyLimit,\r\n\t\t\t\"Sorry! The fund does not have enough funds to match the usersMonthlyLimit.\"\r\n\t\t);\r\n\t\t//The member's Creation-Timestamp must be\r\n\t\t//less-than the current period's Creation-Timestamp\r\n\t\trequire(\r\n\t\t\tmemberObjs[msg.sender].timestampAdded <= lastTimestamp,\r\n\t\t\t\"Sorry! You have not been a member long enough to withdraw funds\"\r\n\t\t);\r\n\t\tmemberLastWithdrawal[msg.sender] = block.timestamp;\r\n\t\t(bool success, ) = payable(msg.sender).call{ value: usersMonthlyLimit }(\r\n\t\t\t\"\"\r\n\t\t);\r\n\t\trequire(success, \"Member Withdrawal failed.\");\r\n\r\n\t\temit MemberWithdrawal(msg.sender, usersMonthlyLimit);\r\n\t}\r\n\r\n\tfunction tryFinishMonth() external {\r\n\t\tif (block.timestamp >= lastTimestamp + frequency) finishMonth();\r\n\t}\r\n\r\n\tfunction returnTimestamp() external view returns (uint256) {\r\n\t\treturn block.timestamp;\r\n\t}\r\n\r\n\tfunction finishMonth() private {\r\n\t\tuint256 prevTimestamp = lastTimestamp;\r\n\t\tlastTimestamp = block.timestamp;\r\n\t\ttotalMonthlyFundsAvailable = address(this).balance;\r\n\t\tusersMonthlyLimit = totalMonthlyFundsAvailable / totalMembers;\r\n\r\n\t\temit Month(\r\n\t\t\tprevTimestamp,\r\n\t\t\tlastTimestamp,\r\n\t\t\ttotalMonthlyFundsAvailable,\r\n\t\t\ttotalMembers,\r\n\t\t\tusersMonthlyLimit\r\n\t\t);\r\n\t}\r\n\r\n\tfunction donate() public payable {\r\n\t\temit Donation(msg.sender, msg.value);\r\n\t}\r\n\r\n\tfunction addressHasVouchedForUser(\r\n\t\taddress _userToVouchFor,\r\n\t\taddress _vouching\r\n\t) private view returns (bool) {\r\n\t\tfor (uint16 i = 0; i < vouches[_userToVouchFor].length; i++)\r\n\t\t\tif (vouches[_userToVouchFor][i] == _vouching) return true;\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\treceive() external payable {\r\n\t\tdonate();\r\n\t}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}